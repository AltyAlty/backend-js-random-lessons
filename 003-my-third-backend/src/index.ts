/*
Установка yarn: npm install --global yarn
Инициализация файла "package.json" (можно добавить флаг "--yes", чтобы не отвечать на вопросы): yarn init
Установка Express: yarn add express
Установка nodemon: yarn add nodemon -D
Установка Typescript, ts-node (для работы с nodemon и Node.js, которому нужен JS), типов для Express, типов для Node.js:
yarn add typescript ts-node @types/express @types/node -D
Инициализация файла "tsconfig.json": yarn tsc --init
Настройка файла "tsconfig.json": в разделе "outDir" указать папку для скомпилированных файлов
Создание скриптов для запуска автоматической компиляции всего приложения в .js и запуска приложения локально через
nodemon с возможностью отладки:
в файл "package.json" перед разделом "dependencies" добавить:
"scripts": {
    "watch": "tsc -w",
    "dev": "nodemon .\\dist\\src\\index.js"
},
Установка Jest, ts-jest, типов для Jest, supertest, типов для supertest:
yarn add -D jest ts-jest @types/jest supertest @types/supertest
Инициализация файла "jest.config.js": yarn ts-jest config:init
Создание скриптов для запуска тестов: в файл "package.json" в раздел "scripts" добавить: "test": "jest"
Установка express-validator: yarn add express-validator
Установка драйвера MongoDB для Node.js: yarn add mongodb
Установка bcrypt: yarn add bcrypt
Установка типов для bcrypt: yarn add -D @types/bcrypt
Установка jsonwebtoken: yarn add jsonwebtoken
Установка типов для jsonwebtoken: yarn add -D @types/jsonwebtoken
Установка nodemailer: yarn add nodemailer
Установка типов для nodemailer: yarn add -D @types/nodemailer
Настройка nodemailer: смотри комментарий ниже касательно использования nodemailer
Установка Mongoose: yarn add mongoose

Запуск приложения:
0. Перед запуском:
Установка всех модулей (если необходимо): yarn install
1.1 Запуск локальной БД:
В файле "index.ts" скрыть вызов функции "connectDB()".
В файле "books-service.ts" импортировать "booksRepository" из файла "books-repository-db-local.ts".
В файле "main-page-service.ts" импортировать "mainPageRepository" из файла "main-page-repository-db-local.ts".
В этом случае будут работать только роутеры "getBooksRouter()", "getTestsRouter()", "getRequestsOrderRouter()" и
"getMainPageRouter()".
1.2 Запуск локальной Mongo БД:
В файле "index.ts" указать вызов функции "connectDB()".
В файле "books-service.ts" импортировать "booksRepository" из файла "books-repository-db-mongo.ts".
В файле "main-page-service.ts" импортировать "mainPageRepository" из файла "main-page-repository-db-mongo.ts".
Смотри комментарий ниже касательно использования MongoDB.
2. Настройка nodemailer: смотри комментарий ниже касательно использования nodemailer.
3. Компиляция TypeScript в JavaScript:
Компиляция одного файла .ts в .js: yarn tsc имя_файла
Компиляция всего приложения в .js: yarn tsc
Автоматическая компиляция всего приложения в .js: yarn tsc -w
Автоматическая компиляция всего приложения в .js (скрипт): yarn watch
4. Запуск приложения:
Запуск приложения локально через nodemon: yarn nodemon .\dist\src\index.js
Запуск приложения локально через nodemon с возможностью отладки: yarn nodemon --inspect .\dist\src\index.js
Запуск приложения локально через nodemon с возможностью отладки (скрипт): yarn dev
5. Тесты (в файле "books-service.ts" импортировать "booksRepository" из файла "books-repository-db-local.ts"):
Запуск e2e-тестов: jest
Запуск e2e-тестов (скрипт): yarn test

Это HTTP-сервер на Express, имеющий архитектуру из трех уровней UI-BLL-DAL и обменивающийся данными c MongoDB. (lessons
007-009, 012-038).
*/

/*CRUD - это отправка на один и тот же end point разных типов запросов для разных типов задач:
C - Create - POST
R - Read - GET
U - Update - PUT/PATCH
D - Delete - DELETE*/

/*URI params (path params) vs Query params (query string):
www.website.com/books/1 - URI-параметры
www.website.com/books?author=fowler&year=2022 - Query-параметры*/

/*Файл "package.json" с точки зрения Node.js это файл, определяющей проект.*/

/*Пакет nodemon - это программа, отслеживающая изменение файлов и автоматически меняющая сервер в браузере без
необходимости его постоянно перезапускать. Такой пакет лучше устанавливать локально и для разработки, то есть указывая
"--save-dev" для npm или "-D" для yarn.*/

/*В файле "tsconfig.json" можно найти раздел "Modules" и в поле "rootDir" указать что нужно компилировать в JS.*/

/*Для тестирования используется связка Jest, ts-jest и supertest.*/

/*Swagger - это программа, которая позволяет генерировать документацию для API.*/

/*Входящие/Исходящие Модели (Input/View Models) - это типы для данных, которые используются в запросах и ответах на
запросы соответственно.*/

/*Пакет express-validator - это набор промежуточных слоев для Express, в который входит обширная коллекция валидаторов и
дезинфицирующих средств, предлагаемых validator.js.*/

/*Вариант просто базовой авторизации: в параметрах запроса указывать в значении по ключу "Authorization" закодированные
в формате Base64 логин и пароль. В данном приложении такого не используется.*/

/*MongoDB - это NoSQL БД, которая использует JSON-подобные документы и схему базы данных. В данном приложении
используется версия MongoDB Community Server. Для управления БД нужно использовать СУБД. В папке с программой есть папка
"bin", в которой находятся скомпилированные файлы БД и СУБД. Сначала нужно запускать БД, а потом СУБД.

ЗАПУСК БД:
Файл "mongod.exe" запускает локальный сервер БД. Чтобы запустить этот файл, нужно открыть окно терминала или окно
PowerShell в папке "bin" и выполнить команду "./mongod.exe --dbpath .\data\db", где ".\data\db" является путем, где вы
хотите иметь саму БД (папки должны быть уже созданы). В нашем случае используется такая команда:
./mongod.exe --dbpath ..\..\..\..\..\DevProjects\BackEndProjects\backend-js-random-lessons\003-my-third-backend\src\db\mongodb\data\db

ЗАПУСК СУБД MongoDB Shell:
MongoDB Shell - это СУБД для работы с Mongo БД. Эта СУБД скачивается отдельно и копируется в туже папке, где находится
Mongo DB. В папке "ишт" файл "mongosh.exe" запускает эту СУБД. Чтобы запустить этот файл, нужно открыть окно терминала
или окно PowerShell в папке "bin" и выполнить команду "./mongosh.exe".

В MongoDB Shell, например, можно использовать следующие команды:
1. use db_name - создание или переключение на БД с именем "db_name".
2. db - определение имени текущей БД.
3. db.getCollection("videos") - указание куда нужно складывать какие-то одинаковые данные (похоже на массив).
4. db.getCollection("videos").insertMany([{name: 'js'},{name: 'react'},{name: 'nodejs'}]) - добавление каких-то
одинаковых данных в указанное место.
5. db.getCollection("videos").find( {} ) - поиск каких-то одинаковых данных в указанном месте.

ЗАПУСК СУБД Studio 3T:
Studio 3T - это еще одна СУБД для работы с Mongo БД. В данном приложении используется версия Studio 3T Community
Edition. Чтобы через Studio 3T подключится к локально запущенной Mongo БД, нужно в СУБД выбрать пункт "Create a new
connection", затем выбрать пункт "Manually configure my connection settings", затем в разделе "Server" указать
"localhost", в разделе "Port" указать "27017", в разделе "Connection name" указать имя соединения (например,
"003-my-third-backend"), затем нажать "Save", затем выбрать соединение и нажать "Connect".

Чтобы создать новую БД в Studio 3T, нужно пкм по имени соединения сверху слева и выбрать "Add Database ...".
Чтобы создать новую коллекцию в Studio 3T, нужно пкм по "Collections" в нужной БД и выбрать "Add Collection ...".
Чтобы выполнять команды в какой-то коллекции в Studio 3T, нужно пкм по нужной коллекции и выбрать "Open IntelliShell".
Команды для инициализации данных в БД для данного приложения смотри в файле "db-mongo.ts".

Список команды для CRUD-операций, которые можно использовать в MongoDB:
1. CREATE:
1.1 Добавление совсем другого типа данных:
db.getCollection("videos").insertMany([{firstName: "John", age: 34}])
1.2 Добавление одного нового документ в коллекцию:
db.inventory.insertOne({item: "canvas", qty: 100, tags: ["cotton"], size: {h: 28, w: 35.5, uom: "cm"}})
1.3 Добавление нескольких новых документов в коллекцию:
db.inventory.insertMany([
   {item: "journal", qty: 25, tags: ["blank", "red"], size: {h: 14, w: 21, uom: "cm"}},
   {item: "mat", qty: 85, tags: ["gray"], size: {h: 27.9, w: 35.5, uom: "cm"}},
   {item: "mousepad", qty: 25, tags: ["gel", "blue"], size: {h: 19, w: 22.85, uom: "cm"}}
])

2. READ:
2.1 Поиск всех документов в коллекции:
db.inventory.find({})
2.2 Поиск документа в коллекции по какому-то признаку:
db.inventory.find({item: "canvas"})
2.3 Поиск документа в коллекции, у которого в значении свойства "item" есть буква "o":
db.inventory.find({ item: {$regex: "o"}})
2.4 Поиск документов в коллекции, у которых значение свойства "status" равно либо "A", либо "D":
db.inventory.find({status: {$in: ["A", "D"]}})
2.5 Поиск документов в коллекции, у которых значение свойства "status" равно "A", а свойство "qty" имеет значение
меньше 30 (AND):
db.inventory.find({status: "A", qty: {$lt: 30}})
2.6 Поиск документов в коллекции, у которых либо значение свойства "status" равно "A", либо свойство "qty" имеет
значение меньше 30 (OR):
db.inventory.find({$or: [{status: "A"}, {qty: {$lt: 30}}]})
2.7 Поиск документов в коллекции, у которых значение свойства "status" равно "A" и либо свойство "qty" имеет значение
меньше 30, либо свойство "item" имеет значение начинающееся с "p" (AND+OR):
db.inventory.find({status: "A", $or: [{qty: {$lt: 30}}, {item: /^p/}]})
2.8 Поиск всех документов в коллекции, пропустив один документ в начале:
db.inventory.find({}).slip(1)
2.9 Поиск всех документов в коллекции, пропустив один документ в начале, и взять первый документ из полученных:
db.inventory.find({}).slip(1).limit(1)
2.10 Подсчет сколько документов в коллекции:
db.inventory.count({})
2.11 Поиск всех документов в коллекции, отсортировав их по свойству (указано два свойства на случай если есть дубликаты
в первом свойстве), 1 означает сортировку по возрастанию (-1 по убыванию):
db.inventory.find({}).sort({ "item": 1, "_id": 1})

3. UPDATE:
3.1 Обновление в коллекции документа, у которого значение свойства "item" равно "paper". У этого документа свойство
"size.uom" станет "cm", свойство "status" станет "P", свойство "lastModified" будет иметь значение равное текущей дате,
причем если этого свойства не было, то оно будет добавлено:
db.inventory.updateOne({ item: "paper" },{$set: {"size.uom": "cm", status: "P"}, $currentDate: {lastModified: true}})
3.2 Обновление в коллекции документов, у которых значение свойства "qty" меньше 50. У этих документов свойство
"size.uom" станет "in", свойство "status" станет "P", свойство "lastModified" будет иметь значение равное текущей дате,
причем если этого свойства не было, то оно будет добавлено:
db.inventory.updateMany({ "qty": { $lt: 50 } }, {$set: {"size.uom": "in", status: "P"}, $currentDate: {lastModified: true}})
3.3 Замена одного документа в коллекции на другой (нельзя менять свойство "_id" и нельзя использовать операторы):
db.inventory.replaceOne({item: "paper"}, {item: "paper", instock: [{warehouse: "A", qty: 60}, {warehouse: "B", qty: 40}]})

4. DELETE:
4.1 Удаление всех документов в коллекции:
db.inventory.deleteMany({})
4.2 Удаление всех документов в коллекции, у которых свойство "status" равно "A":
db.inventory.deleteMany({status : "A"})
4.3 Удаление одного документа в коллекции, у которого свойство "status" равно "D":
db.inventory.deleteOne({status: "D"})

Чем позднее экземпляр ObjectId из MongoDB создан, тем он больше.

Если есть проблемы с уникальными индексами в MongoDB, то можно их удалить:
db.feedbacks.dropIndex("bookID_1")*/

/*Mongoose - это ODM-библиотека (Object Data Modelling), которая занимается преобразованием документов из MongoDB в
объекты JavaScript. Mongoose используется как обертка над драйвером MongoDB. Mongoose предоставляет более удобный API
для работы с Mongo БД. Mongoose позволяет определять схемы для MongoDB, для контроля данных в Mongo БД. Схемы это аналог
типов из TypeScript. При создании схем для MongoDB не нужно указывать свойство "_id". Вместе со схемой нужно
использовать модели - объекты, через которые идет взаимодействие с Mongo БД.

Метод "lean()" в Mongoose возвращает "обычные" JavaScript объекты. Этот метод можно уточнять.*/

/*Библиотека bcrypt используется для создания hash-соли.

При работе с паролями используют однонаправленный хэш. При помощи этого хеша шифруется пароль, но нет возможности его
расшифровать. Таким образом, на сервере хранится не сам пароль, а его хэш.

В целях безопасности также используют хэш-соль - сгенерированную уникально для каждого пользователя строку, которая
особенным образом склеивается с паролем, чтобы потом все вместе хэшировалось.

Аутентификация - это процесс идентификации пользователя.
Авторизация - это процесс определения какие права есть у пользователя.*/

/*При логинизации клиент получает уникальный зашифрованный токен, который предъявляется при работе с сайтом. Этот токен
проверяется на сервере, чтобы удостовериться в личности пользователя. Такие токены прикрепляется к запросам.

Клиент может получить токен, например, через cookies (полученных от сервера), в теле ответа от сервера или в
HTTP-заголовках (более редкая ситуация). Токен шифруется двухсторонним шифрованием, чтобы сервер мог его расшифровать,
получив от клиента.

Для создания JWT используем библиотеку jsonwebtoken. Работа с JWT-токенами является функционалом, необходимым для
презентационного слоя приложения, на при этом напрямую не относящегося к нему, поэтому файл "jwt-application.ts" с этим
функционалом помещаем в отдельную папку "applications".

JWT-токены состоят из 3-х частей:
1) JSON-объект, описывающий метод шифрования, то есть название алгоритма и тип токена.
2) Информация о пользователе, дата создания токена и дата его истечения.
3) Зашифрованные 1 и 2 части.
1 и 2 части идут в слабо зашифрованном виде BASE64. Таким образом, клиент на основе 1 и 2 частей может понять информацию
о токене, а третья часть позволяет проверять был ли подделан токен.

Злоумышленники, например, при помощи XSS-атак могут украсть токен. Если нет каких-либо дополнительных механизмов
проверки, тогда злоумышленники смогут пользоваться этим токеном сколько угодно. Насколько безопасно защищено должно быть
приложение зависит от требований к этому приложению. Примеры дополнительных механизмов проверки:
1. При каждой смене IP-адреса аннулировать токен и просить пройти двухфакторную авторизацию. Неудобно для пользователя,
если он, например, заходит в приложение то с компьютера, то с телефона.
2. При частой смене IP-адреса аннулировать токен и просить пройти двухфакторную авторизацию. Неудобно для пользователя,
если он, например, заходит в приложение одновременно и с компьютера, и с телефона.
3. Выпускать токены с коротким сроком действия, чтобы злоумышленники не могли долго ими пользоваться. Неудобно для
пользователя, так как постоянно приходится вводить учетные данные.
4. Использовать Refresh Token в дополнении к обычному токену (Access Token).

AT используется для доступа к ресурсам. AT должен иметь короткий срок действия в отличие от RT. Когда у AT почти
истекает срок действия клиент должен отправлять RT на специальный end point, чтобы получить новую пару AT/RT. Старый RT
при этом становится недействительным, а текущий AT может оставаться еще рабочим.

RT должен быть защищен сильнее, чем AT. В БД можно хранить список всех недействительных RT, чтобы если злоумышленник
смог воспользоваться одним из них, то он не мог получить новую пару AT/RT.

Но если злоумышленник все-таки смог воспользоваться актуальной парой AT/RT, то он сможет получить новую пару AT/RT,
когда пользователь будет владеть еще старой парой AT/RT, вследствие чего пользователю придется вводить заново свои
учетные данные, чтобы получить новую актуальную пару AT/RT. В таком случае, можно сохранять в БД список устройств и
браузеров, с которых была произведена авторизация, чтобы когда пользователь снова вводил свои учетные данные ему был
доступен список устройств и браузеров, прошедших авторизацию, и он мог отозвать авторизации с неизвестных для него
устройств и браузеров.

RT можно хранить в cookies с флагом "HTTPonly", который не позволяет любому JavaScript-коду иметь доступ к ним. RT может
быть сделан в формате отличном от JWT.

Чтобы ресурсные серверы могли проверять валидность AT, им нужно знать только секрет, используемый при создании
JWT-токена. Актуальные пары AT/RT лучше не хранить в БД, так как сервера могут и без них проверить подлинность AT/RT.
Если все-таки необходимо хранить актуальный RT в БД, то можно хранить только его 1 и 2 части, так как злоумышленники по
сути будут иметь только лишь неподписанный токен и не обладать секретом, используемым для подписания токена.

Также в БД можно хранить дату выпуска RT в дополнении к IP-адресам, устройствам и браузерам. Комбинирую дату выпуска RT,
ID и имя устройства, имя браузера, IP-адрес и ID пользователя, можно построить надежный механизм проверки RT вместо
простого хранения списка недействительных RT, так как такой список недействительных RT будет увеличиваться бесконечно.

При получении новой пары AT/RT клиент может также отправлять ID устройства, чтобы по нему и по дате выдачи последнего RT
можно было проверить валидность присланного от клиента RT. В итоге для каждого авторизованного устройства и браузера в
БД будет храниться отдельная сессия. Когда пользователь выходит из приложения нужно удалять соответствующую
авторизационную сессию из БД.

При проверке RT может быть тяжело определить используется ли сейчас браузер, который использовался в момент создании RT,
так как, например, браузеры достаточно часто обновляют версии. В таком случае можно анализировать другие характеристики,
например разрешение экрана в браузере или поведение пользователя в браузере.

Если на нашей стороне было определено, что произошла утечка данных пользователя и пользователь все еще пользуется
старыми учетными данным, то мы можем удалить все авторизационные сессии пользователя сами и сообщить пользователю о
необходиости обновить учетные данные.*/

/*Протокол SMTP - это протокол для электронных почт. Для работы с таким протоколом мы используем библиотеку nodemailer.
При работе с этой библиотекой нужно указывать хост, который будет заниматься работой с письмами. Также можно указывать
другую информацию в зависимости от хоста.

Создаем отдельный слой адаптеров в папке "adapters". Адаптеры нужны, чтобы адаптировать какой-то сторонний функционал
для приложения. В нашем случае адаптер "emailAdapter" в файле "email-adapter.ts" адаптирует работу библиотеки nodemailer
для нашего приложения.

В папке "managers" создаем дополнительную прослойку менеджеров для организации работы между сервисами и адаптерами. В
файле "email-manager.ts" создаем менеджера "emailManager" для организации работы между сервисами
"emailService"/"usersService" и адаптером "emailAdapter".

Настройка nodemailer: в настройках Google создать пароль приложения (app password) специально для нашего приложения.
Об этом можно узнать больше здесь: https://www.nodemailer.com/usage/using-gmail.

В этом приложение используется способ работы "App Password (requires 2‑Step Verification)" с библиотекой nodemailer.
Настройка данного способа работы:
1. Создать учетную запись Google.
2. Зайти в раздел "Управление аккаунтом Google".
3. Зайти в раздел "Безопасность".
4. Включить двухэтапную верификацию.
5. В поиске найти раздел "Пароли приложений".
6. Ввести название приложения "003-my-third-backend".
7. Нажать "Создать".
8. После создания приложение получить 16-ти значный пароль приложения.
9. В файле "email-adapter.ts" при создании транспортера в свойстве "user" ввести почту, через которую будет
осуществляться рассылка писем, а в свойстве "pass" ввести 16-ти значный пароль приложения.

В реальном приложение почта и 16-ти значный пароль приложения должны браться из переменных окружения.

Если отправка почты по какой-то причине не работает и нужно запустить приложение, то нужно убрать вызов метода
"emailManager.sendEmailConfirmationMail(newUser)" в файле "users-service.ts".*/

/*Против DDOS нет идеальной защиты. Одним из основных способов борьбы с DDOS является определение вредного трафика и
перенаправление его от серверов.

В Express можно определить IP-адрес через свойства "req.socket.localAddress", "req.socket.remoteAddress" и "req.ip".
Если используется прокси, то реальный IP-адрес можно найти в заголовке "x-forwarded" запроса, хотя поскольку заголовки
можно подделать, то IP-адрес там может быть поддельным. Если в Express установить "app.set('trust proxy', true)", то
свойство "req.ip" будет содержать реальный IP-адрес при использовании прокси.*/

/*Если используется системы или сервисы оповещения пользователей по SMS или по Email, то нужно ограничивать частоту
использования таких систем и сервисов, например, не чаще, чем раз в минуту или 100 раз в день, так как за каждое
SMS-сообщение или письмо нужно платить. Для этого в БД можно хранить дату последней отправки SMS или письма. Также в
целях безопасности можно хранить дополнительную информацию: имя и ID операции, ID, почту, телефон и IP-адрес
пользователя. По таким данным можно выявлять злоумышленников.*/

/*CQR(S) - Command and Query Responsibility (Segregation)

CQR - это подход к проектированию программного обеспечения, при котором изменяющий состояние код отделяется от читающего
состояние кода. При CQR запросы делятся на две категории: queries (read) и commands (create, update, delete).

CQR - это про то как разделять методы в коде, а CQRS про то как строить архитектуру системы на основе разделения
ответственностей между командами и запросами.

Уровни архитектуры приложения:
Presentation Layer / UI - REST API (routes) / Websocket / GraphQl / Graph gRPC
↓↓↓
Business Logic Layer / Application Layer / BLL - services
↓↓↓
Data Access Layer / DAL - repositories / Presentation Layer of another back-end

Для команд нужно проходить все три уровня, а для запросов иногда можно игнорировать BLL и, например, делать для них
отдельный query-репозиторий в DAL вместе со специальным сервером, оптимизированным для быстрого чтения, поскольку в
таких случаях порой отсутствует бизнес-логика.

Если при запросе необходимо обратиться к API другого сервера, то можно создать специальный query-сервис в BLL.*/

/*Архитектура приложения:
/src/routes/ - UI - Presentation Layer
Что происходит: формирование роутинга приложения, извлечение данных из запросов для формирования предметной задачи по
получению данных из БД, передача этих данных в BLL, получение результата выполненной предметной задачи из BLL, передача
этого результата клиенту.
↓↓↓
/src/domain/ - BLL - Business Logic Layer
Что происходит: формирование предметной задачи по получению данных из БД на основе данных из запросов от UI, передача
этой задачи в DAL, получение результата выполненной предметной задачи из DAL, передача этого результата в UI.
↓↓↓
/src/repositories/ - DAL - Data Access Layer
Что происходит: выполнение полученной от BLL предметной задачи по получению данных из БД через обращение к Data Source,
передача результата выполненной предметной задачи в BLL.
↓↓↓
/src/db/ - Data Source
Что происходит: подключение к БД, выполнение полученной от DAL предметной задачи по получению данных из БД через прямой
обмен данными с БД.*/

/*Структура приложения:
1. /src/index.ts - главная точка входа в приложение, здесь происходит его запуск.
↓↓↓
1. /src/app.ts - создание приложения на Express и подключение к нему роутеров и middlewares.
↓↓↓
Presentation Layer:
1. /src/routes/books-routes.ts - роутер для работы с данными по книгам.
2. /src/routes/tests-routes.ts - роутер для тестирования, чтобы очищать локальную БД перед запуском тестов.
3. /src/routes/requests-order-routes.ts - роутер для проверки как работает порядок указания запросов в роутерах.
4. /src/routes/main-page-routes.ts - роутер для главной страницы.
5. /src/routes/users-routes.ts - роутер для работы с пользователями.
6. /src/routes/auth-routes.ts - роутер для работы с аутентификацией пользователей.
7. /src/routes/feedbacks-routes.ts - роутер для работы с отзывами.
8. /src/routes/email-routes.ts - роутер для работы с почтой.
↓↓↓
Business Logic Layer:
1. /src/domain/books-service.ts - сервис для работы с данными по книгам.
2. /src/domain/main-page-service.ts - сервис для получения данных для главной страницы.
3. /src/domain/users-service.ts - сервис для работы с пользователями.
4. /src/domain/auth-service.ts - сервис для работы с аутентификацией пользователей.
5. /src/domain/feedbacks-service.ts - сервис для работы с отзывами.
7. /src/domain/email-service.ts - сервис для работы с почтой.
↓↓↓
Data Access Layer:
1. /src/repositories/local/books-repository-db-local.ts - репозиторий для работы с данными по книгам из локальной БД.
2. /src/repositories/mongo/books-repository-db-mongo.ts - репозиторий для работы с данными по книгам из Mongo БД.
3. /src/repositories/local/main-page-repository-db-local.ts - репозиторий для получения данных для главной страницы из
локальной БД.
4. /src/repositories/mongo/main-page-repository-db-mongo.ts - репозиторий для получения данных для главной страницы из
Mongo БД.
5. /src/repositories/mongo/users-repository-db-mongo.ts - репозиторий для работы с пользователями из Mongo БД.
6. /src/repositories/mongo/feedbacks-repository-db-mongo.ts - репозиторий для работы с отзывами из Mongo БД.
↓↓↓
Data Source:
1. /src/db/db-local.ts - локальная БД.
2. /src/db/db-mongo.ts - подключение к Mongo БД.
3. /src/db/mongodb/data/db - сами файлы Mongo БД.

Middlewares:
1. /src/middlewares/request-counter-middleware.ts - middleware, подсчитывающий количество запросов.
2. /src/middlewares/useless-info-middleware.ts - middleware, предоставляющий дополнительные данные.
3. /src/middlewares/fake-authorization-middleware.ts - middleware, имитирующий авторизацию пользователей по токену.
4. /src/middlewares/books-middlewares.ts - middlewares, проверяющие названия книг.
5. /src/middlewares/authorization-middleware.ts - middleware, авторизующий пользователей по токену.

Приложения:
1. /src/applications/jwt-application.ts - приложение для работы с JWT-токенами.

Менеджеры:
1. /src/managers/email-manager.ts - менеджер "emailManager" для организации работы между сервисами
"emailService"/"usersService" и адаптером "emailAdapter".

Адаптеры:
1. /src/adapters/email-adapter.ts - адаптер работы библиотеки nodemailer для приложения.

Типы, модели, Mongoose схемы и Mongoose модели:
1. /src/routes/types/routes-types.ts - типы для запросов.
2. /src/db/types/db-types.ts - типы для локальной БД и Mongo БД.
3. /src/types/index.d.ts - расширение типов.
4. /src/adapters/types/email-types.ts - типы для адаптера "emailAdapter".
5. /src/models/ - входящие/исходящие модели.
6. /src/db/schemas/schemas.ts - Mongoose схемы и Mongoose модели.

Утилиты:
1. /src/utils/utils.ts - объект с HTTP-статусами для приложения.

Настройки:
1. /src/settings.ts - объект с переменными окружения, используемыми в приложении.

Тесты:
1. /__test__/e2e/back.api.test.ts - e2e-тесты для локальной версии БД.

Прочее:
1. /src/query-repositories/video-query-repository.ts - фиктивный пример использования queries из CQR.
2. /dist/ - скомпилированное в JavaScript приложение.*/

/*Импортируем наше приложение на Express.*/
import {app} from './app';
/*Импортируем функцию "connectDB()" для присоединения к Mongo БД.*/
import {connectDB} from './db/db-mongo';

/*Делаем так, чтобы порт определялся автоматически от окружения.*/
const port = process.env.PORT || 3000;

/*Создаем функцию "startApp()" для запуска приложения.*/
const startApp = async () => {
    /*Пытаемся присоединиться к Mongo БД. По какой-то причине все работает даже без вызова этой функции.*/
    await connectDB();
    /*Устанавливаем порт для прослушивания.*/
    app.listen(port, () => { console.log(`003-my-third-backend app listening on port ${port}`) });
};

/*Запускаем приложение.*/
startApp();